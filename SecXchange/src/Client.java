import org.json.JSONObject;
import org.json.JSONTokener;

import javax.crypto.spec.SecretKeySpec;
import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;
import java.io.*;
import java.math.BigInteger;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.KeySpec;
import java.security.spec.RSAPrivateKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * Client sharing messages with a server
 * @author Tristan Guerin
 * @version 1.0
 */
public class Client extends UserRSA{

    /**
     * Secret key generated by the password initially entered
     */
    private SecretKeySpec secretKeySpec;

    /**
     * Frame of the application
     */
    private JFrame fenetre = new JFrame();

    /**
     * JTextPane showing the messages history
     */
    private JTextPane textPane = new JTextPane();

    /**
     * JScrollPane containing textPane
     */
    private JScrollPane scrollPane = new JScrollPane(textPane);

    /**
     * JTextPane used to write messages
     */
    private JTextPane textPane2 = new JTextPane();

    /**
     * JScrollPane containing textPane2
     */
    private JScrollPane scrollPane2 = new JScrollPane(textPane2);

    /**
     * JButton used to send messages
     */
    private JButton jButton = new JButton("Send message");

    /**
     * Name of the interlocutor server user
     */
    private String otherUser;

    /**
     * RSA public key of the interlocutor
     */
    private RSAPublicKey otherUserPublicKey;

    /**
     * Current date
     */
    private Date date;

    /**
     * Main of the app
     * @param args list of arguments
     * @throws IOException
     */
    public static void main(String args[]) throws IOException {
        Client client = new Client();
        JFrame fenetre = client.getFenetre();
        fenetre.setTitle("SecXchange - Client");
        fenetre.setLocationRelativeTo(null);
        fenetre.setSize(1000, 549);
        fenetre.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        BufferedImage myImage = ImageIO.read(new File("background.jpg"));
        fenetre.setContentPane(new ImagePanel(myImage));
        client.beginning();
        fenetre.setVisible(true);
    }


    /**
     * Constructs objects from class Client
     */
    public Client(){
        super(null,null);
    }

    /**
     * Initialize discussion
     * @param ip ip of the server
     * @param port connection port
     */
    public void discussion(String ip, int port){
        final Socket clientSocket;
        final BufferedReader in;
        final PrintWriter out;
        try {
            clientSocket = new Socket(ip,port);
            //System.out.println("Server connection");
            out = new PrintWriter(clientSocket.getOutputStream());
            in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

            // Bi-directionnal authentication between client and server
            SecureRandom secureRandom = new SecureRandom();
            int alea1 = secureRandom.nextInt(10000);
            out.println(this.getNameUser());
            out.flush();
            out.println(alea1);
            out.flush();
            String alea1enc = in.readLine();
            String alea2 = in.readLine();
            otherUser = in.readLine();
            otherUserPublicKey = getPublicKey(otherUser);
            String alea1dec = UserRSA.decrypt(alea1enc,otherUserPublicKey);
            if(!alea1dec.equals(String.valueOf(alea1))){
                throw new Exception("Random 1 not the same");
            }
            String alea2enc = UserRSA.encrypt(alea2,this.getPrivateKey());
            out.println(alea2enc);
            out.flush();
            // End of authentication
            DateFormat format = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");

            Thread envoyer = new Thread(new Runnable() {
                String msg;
                @Override
                public void run() {
                    jButton.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent e) {
                            String text = textPane2.getText();
                            textPane2.setText("");
                            date = new Date();

                            SimpleAttributeSet italic=new SimpleAttributeSet();
                            StyleConstants.setItalic(italic, true);
                            StyleConstants.setForeground(italic, Color.BLUE);
                            StyledDocument doc=textPane.getStyledDocument();
                            try {
                                doc.insertString(doc.getLength(),"You at "+format.format(date)+" :\n",italic);
                                doc.insertString(doc.getLength(),text+"\n",null);
                            } catch (BadLocationException ex) {
                                ex.printStackTrace();
                            }
                            String enc ="";
                            try {
                                // Encryption of the message with private RSA key
                                enc = UserRSA.encrypt(text,getPrivateKey());
                            } catch (Exception ex) {
                                ex.printStackTrace();
                            }
                            out.println(getNameUser()+':'+enc);
                            out.flush();
                        }
                    });
                }
            });
            envoyer.start();

            Thread recevoir = new Thread(new Runnable() {
                String msg;
                @Override
                public void run() {
                    try {
                        String enc = in.readLine();
                        int pos = enc.indexOf(':');
                        if(pos == -1){
                            throw new Exception("Error while encryption");
                        }
                        if(!enc.substring(0,pos).equals(otherUser)){
                            System.out.println(enc.substring(0,pos));
                            throw new Exception("Error with source messenger");
                        }
                        msg =UserRSA.decrypt(enc.substring(pos+1),otherUserPublicKey);
                        SimpleAttributeSet italic=new SimpleAttributeSet();
                        StyleConstants.setItalic(italic, true);
                        StyleConstants.setForeground(italic, Color.RED);
                        StyledDocument doc=textPane.getStyledDocument();
                        while(!msg.contains("!quit")){
                            date = new Date();
                            doc.insertString(doc.getLength(),otherUser+" at "+format.format(date)+" :\n",italic);
                            doc.insertString(doc.getLength(),msg+"\n",null);
                            enc = in.readLine();
                            pos = enc.indexOf(':');
                            if(pos == -1){
                                throw new Exception("Error while encryption");
                            }
                            if(!enc.substring(0,pos).equals(otherUser)){
                                System.out.println(enc.substring(0,pos));
                                throw new Exception("Error with source messenger");
                            }
                            msg =UserRSA.decrypt(enc.substring(pos+1),otherUserPublicKey);
                        }
                        out.close();
                        clientSocket.close();
                        System.exit(0);
                    } catch (Exception e) {
                        //e.printStackTrace();
                        System.exit(0);
                    }
                }
            });
            recevoir.start();
        } catch (Exception e) {
            //e.printStackTrace();
            System.exit(0);
        }
    }

    /**
     * Gets the secret key
     * @return secret key
     */
    public SecretKeySpec getSecretKeySpec() {
        return secretKeySpec;
    }

    /**
     * Sets the secret key
     * @param secretKeySpec secret key to set
     */
    public void setSecretKeySpec(SecretKeySpec secretKeySpec) {
        this.secretKeySpec = secretKeySpec;
    }

    /**
     * Gets the frame
     * @return frame
     */
    public JFrame getFenetre() {
        return fenetre;
    }

    /**
     * Initialize the id verification phase
     */
    public void beginning(){
        JLabel labelUser = new JLabel("Username");
        labelUser.setText("Username :");
        JTextField textFieldUser = new JTextField();
        JLabel labelPassword = new JLabel("Password");
        labelPassword.setText("Password :");
        JPasswordField passwordField = new JPasswordField(10);
        passwordField.setEchoChar('*');
        JButton btnLogin = new JButton("Login");
        JLabel labelPort = new JLabel();
        labelPort.setText("Connection port :");
        JTextField textFieldPort = new JTextField();
        textFieldPort.setText("2000");
        JLabel labelIP = new JLabel();
        labelIP.setText("Connection ip :");
        JTextField textFieldIP = new JTextField();

        fenetre.add(labelUser);fenetre.add(labelPassword);
        fenetre.add(textFieldUser);fenetre.add(passwordField);
        fenetre.add(btnLogin);
        fenetre.add(labelPort);fenetre.add(textFieldPort);
        fenetre.add(labelIP);fenetre.add(textFieldIP);

        labelUser.setBounds(450,230,100,26);
        labelPassword.setBounds(450,280,100,26);
        textFieldUser.setBounds(400, 250, 200, 26);
        passwordField.setBounds(400, 300, 200, 26);
        btnLogin.setBounds(450,330,100,26);
        labelPort.setBounds(450,385,100,26);
        textFieldPort.setBounds(450,410,100,26);
        labelIP.setBounds(450,430,100,26);
        textFieldIP.setBounds(450,455,100,26);

        Client client = this;
        btnLogin.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                try {
                    List<KeySpec> list = client.verifPassword(textFieldUser.getText(),String.valueOf(passwordField.getPassword()));
                    if(list.get(0)==null || list.get(1)==null){
                    }else{
                        System.out.println("id confirmed");
                        setNameUser(textFieldUser.getText());
                        client.setPublicKey((RSAPublicKeySpec) list.get(0));
                        client.setPrivateKey((RSAPrivateKeySpec) list.get(1));fenetre.remove(labelUser);
                        fenetre.remove(labelPassword);fenetre.remove(textFieldUser);fenetre.remove(passwordField);
                        fenetre.remove(btnLogin);fenetre.remove(labelPort);fenetre.remove(textFieldPort);
                        fenetre.remove(labelIP);fenetre.remove(textFieldIP);

                        textPane.setEditable(false);
                        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
                        scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
                        textPane2.setEditable(true);
                        scrollPane2.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
                        scrollPane2.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

                        fenetre.add(jButton);
                        fenetre.add(scrollPane);
                        fenetre.add(scrollPane2);
                        scrollPane.setBounds(85,75,400,400);
                        scrollPane2.setBounds(550,125,300,100);
                        jButton.setBounds(600,275,200,26);


                        discussion(textFieldIP.getText(),Integer.parseInt(textFieldPort.getText()));
                        JTextPane textDiscussion = new JTextPane();
                        SimpleAttributeSet colorRed=new SimpleAttributeSet();
                        StyleConstants.setForeground(colorRed, Color.RED);
                        SimpleAttributeSet colorBlue=new SimpleAttributeSet();
                        StyleConstants.setForeground(colorBlue, Color.BLUE);
                        StyledDocument doc=textDiscussion.getStyledDocument();

                        doc.insertString(doc.getLength(),"Connected as ",null);
                        doc.insertString(doc.getLength(),getNameUser()+"\n",colorBlue);
                        doc.insertString(doc.getLength(),"Discussion with ",null);
                        doc.insertString(doc.getLength(),otherUser+"\n",colorRed);

                        textDiscussion.setEditable(false);
                        textDiscussion.setBounds(85,30,300,35);
                        fenetre.add(textDiscussion);
                        fenetre.repaint();
                    }
                } catch (Exception ex) {
                    //ex.printStackTrace();
                    System.exit(0);
                }
            }
        });
    }

    /**
     * Verify the password entered by the user
     * @param username username entered
     * @param password password entered
     * @return pair of public/private RSA key thanks to the hashed password
     */
    public List<KeySpec> verifPassword(String username, String password){
        RSAPrivateKeySpec privateKeySpec = null;
        RSAPublicKeySpec publicKeySpec = null;
        List<KeySpec> list = new ArrayList<KeySpec>();
        try {
            File file1 = new File("public_RSA_keys.json");
            InputStream in1 = new FileInputStream(file1);
            File file2 = new File("private_RSA_key.json");
            InputStream in2 = new FileInputStream(file2);

            JSONTokener token1 = new JSONTokener(this.loadString(in1));
            JSONObject object1 = new JSONObject(token1);
            JSONTokener token2 = new JSONTokener(this.loadString(in2));
            JSONObject object2 = new JSONObject(token2);

            JSONObject user = object1.getJSONObject(username);
            BigInteger modulus = new BigInteger(user.getString("modulus"));
            BigInteger exponent = new BigInteger(String.valueOf(user.getInt("exponent")));

            JSONObject userbis = object2.getJSONObject(username);
            String hashPassword = (userbis.getString("hashPassword"));

            MessageDigest md = MessageDigest.getInstance("SHA-512");
            byte[] bytes = md.digest(password.getBytes(StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            StringBuilder sb2 = new StringBuilder();
            for (int i = 0; i < bytes.length; i++) {
                if (i % 4 == 0) {
                    sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
                }
                sb2.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
            }
            String hashedPassword = sb.toString();
            String hashedPassword2 = sb2.toString();

            if(!hashedPassword2.equals(hashPassword)){
                throw new Exception("Invalid Password");
            }
            String modulusbis = (userbis.getString("modulus"));
            String exponentbis = (userbis.getString("exponent"));

            SecretKeySpec sec = new SecretKeySpec(hashedPassword.getBytes(),"AES");
            this.setSecretKeySpec(sec);

            publicKeySpec = new RSAPublicKeySpec(modulus,exponent);

            String decryptM = AES.decrypt(modulusbis,this.getSecretKeySpec());
            String decryptE = AES.decrypt(exponentbis,this.getSecretKeySpec());

            privateKeySpec = new RSAPrivateKeySpec(new BigInteger(decryptM),new BigInteger(decryptE));
        }catch (Exception e){
        }finally {
            list.add(publicKeySpec);
            list.add(privateKeySpec);
            return list;
        }
    }
}
